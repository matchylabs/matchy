/* Matchy - Fast Database for IP and Pattern Matching */

#ifndef MATCHY_H
#define MATCHY_H

/* Generated with cbindgen:0.29.2 */

/* WARNING: Auto-generated by cbindgen. Do not edit manually. */

#include <stdarg.h>
#include <stdbool.h>
#include <stdint.h>
#include <stdlib.h>
/* Platform-specific includes for sockaddr and FILE */
#include <stdio.h>
#ifdef _WIN32
    #include <winsock2.h>
    #include <ws2tcpip.h>
#else
    #include <sys/socket.h>
#endif

/* Entry data value union (cbindgen doesn't export unions, so we define it manually) */
typedef union matchy_entry_data_value_u {
    uint32_t pointer;
    const char *utf8_string;
    double double_value;
    const uint8_t *bytes;
    uint16_t uint16;
    uint32_t uint32;
    int32_t int32;
    uint64_t uint64;
    uint8_t uint128[16];
    bool boolean;
    float float_value;
} matchy_entry_data_value_u;


#ifdef __cplusplus
namespace matchy {
#endif  // __cplusplus

/*
 Success code
 */
#define MATCHY_SUCCESS 0

/*
 File not found error
 */
#define MATCHY_ERROR_FILE_NOT_FOUND -1

/*
 Invalid format error
 */
#define MATCHY_ERROR_INVALID_FORMAT -2

/*
 Corrupt data error
 */
#define MATCHY_ERROR_CORRUPT_DATA -3

/*
 Out of memory error
 */
#define MATCHY_ERROR_OUT_OF_MEMORY -4

/*
 Invalid parameter error
 */
#define MATCHY_ERROR_INVALID_PARAM -5

/*
 I/O error
 */
#define MATCHY_ERROR_IO -6

/*
 Schema validation error
 */
#define MATCHY_ERROR_SCHEMA_VALIDATION -7

/*
 Unknown schema error
 */
#define MATCHY_ERROR_UNKNOWN_SCHEMA -8

/*
 MMDB data type constants (matching libmaxminddb)
 Extended type marker (internal use)
 */
#define MATCHY_DATA_TYPE_EXTENDED 0

/*
 Pointer type for data section references
 */
#define MATCHY_DATA_TYPE_POINTER 1

/*
 UTF-8 encoded string
 */
#define MATCHY_DATA_TYPE_UTF8_STRING 2

/*
 Double precision float (64-bit)
 */
#define MATCHY_DATA_TYPE_DOUBLE 3

/*
 Byte array / binary data
 */
#define MATCHY_DATA_TYPE_BYTES 4

/*
 Unsigned 16-bit integer
 */
#define MATCHY_DATA_TYPE_UINT16 5

/*
 Unsigned 32-bit integer
 */
#define MATCHY_DATA_TYPE_UINT32 6

/*
 Map/dictionary type
 */
#define MATCHY_DATA_TYPE_MAP 7

/*
 Signed 32-bit integer
 */
#define MATCHY_DATA_TYPE_INT32 8

/*
 Unsigned 64-bit integer
 */
#define MATCHY_DATA_TYPE_UINT64 9

/*
 Unsigned 128-bit integer
 */
#define MATCHY_DATA_TYPE_UINT128 10

/*
 Array type
 */
#define MATCHY_DATA_TYPE_ARRAY 11

/*
 Boolean type
 */
#define MATCHY_DATA_TYPE_BOOLEAN 14

/*
 Single precision float (32-bit)
 */
#define MATCHY_DATA_TYPE_FLOAT 15

/*
 Additional error codes for structured data API
 Invalid lookup path specified
 */
#define MATCHY_ERROR_LOOKUP_PATH_INVALID -7

/*
 No data available at the specified path
 */
#define MATCHY_ERROR_NO_DATA -8

/*
 Failed to parse data value
 */
#define MATCHY_ERROR_DATA_PARSE -9

/*
 Standard validation level - all offsets, UTF-8, basic structure
 */
#define MATCHY_VALIDATION_STANDARD 0

/*
 Strict validation level - standard plus deep graph analysis and consistency checks (default)
 */
#define MATCHY_VALIDATION_STRICT 1

/*
 Extract domain names (e.g., "example.com")
 */
#define MATCHY_EXTRACT_DOMAINS (1 << 0)

/*
 Extract email addresses (e.g., "user@example.com")
 */
#define MATCHY_EXTRACT_EMAILS (1 << 1)

/*
 Extract IPv4 addresses
 */
#define MATCHY_EXTRACT_IPV4 (1 << 2)

/*
 Extract IPv6 addresses
 */
#define MATCHY_EXTRACT_IPV6 (1 << 3)

/*
 Extract file hashes (MD5, SHA1, SHA256, SHA384, SHA512)
 */
#define MATCHY_EXTRACT_HASHES (1 << 4)

/*
 Extract Bitcoin addresses
 */
#define MATCHY_EXTRACT_BITCOIN (1 << 5)

/*
 Extract Ethereum addresses
 */
#define MATCHY_EXTRACT_ETHEREUM (1 << 6)

/*
 Extract Monero addresses
 */
#define MATCHY_EXTRACT_MONERO (1 << 7)

/*
 Extract all supported types
 */
#define MATCHY_EXTRACT_ALL 255

/*
 Domain name
 */
#define MATCHY_ITEM_TYPE_DOMAIN 0

/*
 Email address
 */
#define MATCHY_ITEM_TYPE_EMAIL 1

/*
 IPv4 address
 */
#define MATCHY_ITEM_TYPE_IPV4 2

/*
 IPv6 address
 */
#define MATCHY_ITEM_TYPE_IPV6 3

/*
 MD5 hash (32 hex characters)
 */
#define MATCHY_ITEM_TYPE_MD5 4

/*
 SHA1 hash (40 hex characters)
 */
#define MATCHY_ITEM_TYPE_SHA1 5

/*
 SHA256 hash (64 hex characters)
 */
#define MATCHY_ITEM_TYPE_SHA256 6

/*
 SHA384 hash (96 hex characters)
 */
#define MATCHY_ITEM_TYPE_SHA384 7

/*
 SHA512 hash (128 hex characters)
 */
#define MATCHY_ITEM_TYPE_SHA512 8

/*
 Bitcoin address
 */
#define MATCHY_ITEM_TYPE_BITCOIN 9

/*
 Ethereum address
 */
#define MATCHY_ITEM_TYPE_ETHEREUM 10

/*
 Monero address
 */
#define MATCHY_ITEM_TYPE_MONERO 11

/*
 Opaque database builder handle
 */
typedef struct matchy_builder_t {
  uint8_t _private[0];
} matchy_builder_t;

/*
 Reload callback event information

 Information passed to reload callbacks when database reloads occur.
 */
typedef struct matchy_reload_event_t {
  /*
   Path to database file (null-terminated C string)
   Valid only for duration of callback - copy if needed
   */
  const char *path;
  /*
   Whether reload succeeded
   true = successful reload, false = reload failed
   */
  bool success;
  /*
   Error message if reload failed (null if success)
   Valid only for duration of callback - copy if needed
   */
  const char *error;
  /*
   Generation counter (increments on each successful reload)
   Can be used to detect if database has changed since last check
   */
  uint64_t generation;
} matchy_reload_event_t;

/*
 Reload callback function type

 Called when database reload completes (success or failure).
 Called from watcher thread - keep processing minimal!

 # Parameters
 * `event` - Reload event information (valid only during callback)
 * `user_data` - User-provided context pointer from matchy_open_options_t

 # Safety
 * Callback must be thread-safe
 * Do not call matchy_* functions from callback (potential deadlock)
 * Copy event.path and event.error if you need them after callback returns
 * user_data must match what was provided in options

 # Example
 ```c
 void on_reload(const matchy_reload_event_t *event, void *user_data) {
     if (event->success) {
         printf("Database reloaded: %s (generation %lu)\n",
                event->path, event->generation);
     } else {
         fprintf(stderr, "Reload failed: %s - %s\n",
                 event->path, event->error);
     }
 }
 ```
 */
typedef void (*matchy_reload_callback_t)(const struct matchy_reload_event_t *event, void *user_data);

/*
 Database opening options

 Configure how databases are loaded, including cache settings and validation.
 */
typedef struct matchy_open_options_t {
  /*
   LRU cache capacity
   0 = disable cache, >0 = cache this many entries
   Default: 10000
   */
  uint32_t cache_capacity;
  /*
   Enable automatic reload when database file changes
   false = no watching (default), true = auto-reload on file changes
   Default: false

   When enabled, the database watches its source file and automatically
   reloads when changes are detected. All queries transparently use the
   latest version. Adds ~10-20ns overhead per query due to read lock.
   */
  bool auto_reload;
  /*
   Reload callback function (optional)
   Called when database reload completes (success or failure)
   Set to NULL to disable callback
   Default: NULL
   */
  matchy_reload_callback_t reload_callback;
  /*
   User data pointer passed to reload callback
   Can be any pointer - callback receives it as-is
   Default: NULL
   */
  void *reload_callback_user_data;
} matchy_open_options_t;

/*
 Opaque database handle
 */
typedef struct matchy_t {
  uint8_t _private[0];
} matchy_t;

/*
 Database statistics
 */
typedef struct matchy_stats_t {
  /*
   Total number of queries executed
   */
  uint64_t total_queries;
  /*
   Queries that found a match
   */
  uint64_t queries_with_match;
  /*
   Queries that found no match
   */
  uint64_t queries_without_match;
  /*
   Cache hits (query served from cache)
   */
  uint64_t cache_hits;
  /*
   Cache misses (query required lookup)
   */
  uint64_t cache_misses;
  /*
   Number of IP address queries
   */
  uint64_t ip_queries;
  /*
   Number of string queries (literal or pattern)
   */
  uint64_t string_queries;
} matchy_stats_t;

/*
 Query result
 */
typedef struct matchy_result_t {
  /*
   Whether a match was found
   */
  bool found;
  /*
   Network prefix length (for IP results)
   */
  uint8_t prefix_len;
  /*
   Internal pointer to cached DataValue (opaque, for structured data access)
   */
  void *_data_cache;
  /*
   Internal database reference (for entry.db population)
   */
  const struct matchy_t *_db_ref;
} matchy_result_t;

/*
 Entry handle (like MMDB_entry_s)
 */
typedef struct matchy_entry_s {
  /*
   Database handle
   */
  const struct matchy_t *db;
  /*
   Cached data pointer (internal)
   */
  const void *data_ptr;
} matchy_entry_s;

/*
 Entry data structure (like MMDB_entry_data_s)
 */
typedef struct matchy_entry_data_t {
  /*
   Whether data was found
   */
  bool has_data;
  /*
   Data type (one of MATCHY_DATA_TYPE_* constants)
   */
  uint32_t type_;
  /*
   Actual data value
   */
  union matchy_entry_data_value_u value;
  /*
   Size in bytes (for strings, bytes, maps, arrays)
   */
  uint32_t data_size;
  /*
   Internal offset (for debugging)
   */
  uint32_t offset;
} matchy_entry_data_t;

/*
 Entry data list node (like MMDB_entry_data_list_s)
 */
typedef struct matchy_entry_data_list_t {
  /*
   The entry data for this node
   */
  struct matchy_entry_data_t entry_data;
  /*
   Pointer to the next node in the list (NULL if last)
   */
  struct matchy_entry_data_list_t *next;
} matchy_entry_data_list_t;

/*
 Opaque extractor handle
 */
typedef struct matchy_extractor_t {
  uint8_t _private[0];
} matchy_extractor_t;

/*
 A single extracted match
 */
typedef struct matchy_match_t {
  /*
   Item type (one of MATCHY_ITEM_TYPE_* constants)
   */
  uint8_t item_type;
  /*
   The extracted value as a null-terminated string
   Valid for the lifetime of the matchy_matches_t
   */
  const char *value;
  /*
   Byte offset where the match starts in the input
   */
  uintptr_t start;
  /*
   Byte offset where the match ends in the input (exclusive)
   */
  uintptr_t end;
} matchy_match_t;

/*
 Array of extracted matches
 */
typedef struct matchy_matches_t {
  /*
   Pointer to array of matches
   */
  const struct matchy_match_t *items;
  /*
   Number of matches
   */
  uintptr_t count;
  /*
   Internal pointer (do not use)
   */
  void *_internal;
} matchy_matches_t;

#ifdef __cplusplus
extern "C" {
#endif // __cplusplus

/*
 Create a new database builder

 # Returns
 * Non-null pointer on success
 * NULL on allocation failure

 # Example
 ```c
 matchy_builder_t *builder = matchy_builder_new();
 if (builder == NULL) {
     fprintf(stderr, "Failed to create builder\n");
     return 1;
 }
 ```
 */
struct matchy_builder_t *matchy_builder_new(void);

/*
 Set case-insensitive matching mode

 When enabled, all pattern/literal lookups will be case-insensitive.
 IP lookups are always case-insensitive regardless of this setting.

 # Parameters
 * `builder` - Builder handle (must not be NULL)
 * `case_insensitive` - true for case-insensitive, false for case-sensitive (default)

 # Returns
 * MATCHY_SUCCESS (0) on success
 * MATCHY_ERROR_INVALID_PARAM if builder is NULL

 # Safety
 * `builder` must be a valid pointer returned by `matchy_builder_new()` or NULL
 * `builder` must not have been freed with `matchy_builder_free()`

 # Example
 ```c
 matchy_builder_t *builder = matchy_builder_new();
 matchy_builder_set_case_insensitive(builder, true);
 // Entries like "Evil.COM" will match queries for "evil.com", "EVIL.COM", etc.
 ```
 */
int32_t matchy_builder_set_case_insensitive(struct matchy_builder_t *builder, bool case_insensitive);

/*
 Enable schema validation for a known database type

 When a schema is set, all entries added via matchy_builder_add() will be
 validated against the schema. Invalid entries will cause add to return
 MATCHY_ERROR_SCHEMA_VALIDATION.

 Known database types:
 - "threatdb" - Threat intelligence database (ThreatDB-v1 schema)

 # Parameters
 * `builder` - Builder handle (must not be NULL)
 * `schema_name` - Name of a known schema (e.g., "threatdb")

 # Returns
 * MATCHY_SUCCESS (0) on success
 * MATCHY_ERROR_UNKNOWN_SCHEMA if the schema name is not recognized
 * MATCHY_ERROR_INVALID_PARAM if builder or schema_name is NULL

 # Safety
 * `builder` must be a valid pointer returned by `matchy_builder_new()` or NULL
 * `builder` must not have been freed with `matchy_builder_free()`
 * `schema_name` must be a valid null-terminated C string or NULL

 # Example
 ```c
 matchy_builder_t *builder = matchy_builder_new();
 int result = matchy_builder_set_schema(builder, "threatdb");
 if (result != MATCHY_SUCCESS) {
     fprintf(stderr, "Unknown schema\n");
     return 1;
 }
 // Now all entries will be validated against ThreatDB schema
 ```
 */
int32_t matchy_builder_set_schema(struct matchy_builder_t *builder, const char *schema_name);

/*
 Add an entry with associated data (as JSON)

 Automatically detects whether the key is an IP address, CIDR range, or pattern.

 # Parameters
 * `builder` - Builder handle (must not be NULL)
 * `key` - IP address, CIDR, or pattern (null-terminated C string, must not be NULL)
 * `json_data` - Associated data as JSON (null-terminated C string, must not be NULL)

 # Returns
 * MATCHY_SUCCESS (0) on success
 * Error code < 0 on failure

 # Safety
 * `builder` must be a valid pointer from matchy_builder_new
 * `key` must be a valid null-terminated C string
 * `json_data` must be a valid null-terminated C string containing valid JSON

 # Example
 ```c
 matchy_builder_add(builder, "1.2.3.4", "{\"threat_level\": \"high\"}");
 matchy_builder_add(builder, "10.0.0.0/8", "{\"type\": \"internal\"}");
 matchy_builder_add(builder, "*.evil.com", "{\"category\": \"malware\"}");
 ```
 */
int32_t matchy_builder_add(struct matchy_builder_t *builder, const char *key, const char *json_data);

/*
 Set database description

 # Parameters
 * `builder` - Builder handle (must not be NULL)
 * `description` - Description text (null-terminated C string, must not be NULL)

 # Returns
 * MATCHY_SUCCESS (0) on success
 * Error code < 0 on failure

 # Safety
 * `builder` must be a valid pointer from matchy_builder_new
 * `description` must be a valid null-terminated C string
 */
int32_t matchy_builder_set_description(struct matchy_builder_t *builder, const char *description);

/*
 Build and save database to file

 # Parameters
 * `builder` - Builder handle (must not be NULL)
 * `filename` - Path where file should be written (null-terminated C string, must not be NULL)

 # Returns
 * MATCHY_SUCCESS (0) on success
 * Error code < 0 on failure

 # Safety
 * `builder` must be a valid pointer from matchy_builder_new
 * `filename` must be a valid null-terminated C string

 # Example
 ```c
 if (matchy_builder_save(builder, "threats.db") != MATCHY_SUCCESS) {
     fprintf(stderr, "Failed to save database\n");
 }
 ```
 */
int32_t matchy_builder_save(struct matchy_builder_t *builder, const char *filename);

/*
 Build and return database in memory

 # Parameters
 * `builder` - Builder handle (must not be NULL)
 * `buffer` - Pointer to receive the buffer pointer (must not be NULL)
 * `size` - Pointer to receive the buffer size (must not be NULL)

 # Returns
 * MATCHY_SUCCESS (0) on success
 * Error code < 0 on failure

 # Safety
 * `builder` must be a valid pointer from matchy_builder_new
 * `buffer` and `size` must be valid pointers
 * Caller must free the returned buffer with libc::free()

 # Example
 ```c
 uint8_t *buffer = NULL;
 size_t size = 0;
 if (matchy_builder_build(builder, &buffer, &size) == MATCHY_SUCCESS) {
     // Use buffer...
     free(buffer);
 }
 ```
 */
int32_t matchy_builder_build(struct matchy_builder_t *builder, uint8_t **buffer, uintptr_t *size);

/*
 Free builder

 # Parameters
 * `builder` - Builder handle (may be NULL)

 # Safety
 * `builder` must be NULL or a valid pointer from matchy_builder_new
 * Must not be used after calling this function
 * Calling with NULL is safe (no-op)
 */
void matchy_builder_free(struct matchy_builder_t *builder);

/*
 Initialize database opening options with defaults

 Sets default values:
 - cache_capacity = 10000
 - auto_reload = false

 # Parameters
 * `options` - Pointer to options struct to initialize (must not be NULL)

 # Safety
 * `options` must be a valid pointer

 # Example
 ```c
 matchy_open_options_t opts;
 matchy_init_open_options(&opts);
 opts.cache_capacity = 100000;  // Custom size
 opts.auto_reload = true;        // Enable auto-reload
 matchy_t *db = matchy_open_with_options("threats.mxy", &opts);
 ```
 */
void matchy_init_open_options(struct matchy_open_options_t *options);

/*
 Open database with custom options

 Opens a database file with configurable cache size, auto-reload, and validation settings.

 # Parameters
 * `filename` - Path to database file (null-terminated C string, must not be NULL)
 * `options` - Opening options (must not be NULL)

 # Returns
 * Non-null pointer on success
 * NULL on failure

 # Safety
 * `filename` must be a valid null-terminated C string
 * `options` must be a valid pointer

 # Example
 ```c
 // High-performance mode with auto-reload
 matchy_open_options_t opts;
 matchy_init_open_options(&opts);
 opts.cache_capacity = 100000; // Large cache
 opts.auto_reload = true;      // Watch file for changes

 matchy_t *db = matchy_open_with_options("threats.mxy", &opts);
 if (db == NULL) {
     fprintf(stderr, "Failed to open database\n");
     return 1;
 }

 // Queries automatically use latest database version
 matchy_result_t result;
 matchy_lookup(db, "1.2.3.4", &result);
 ```
 */
struct matchy_t *matchy_open_with_options(const char *filename, const struct matchy_open_options_t *options);

/*
 Open database from file (memory-mapped) - SAFE mode

 Opens a database file using memory mapping for optimal performance.
 The file is not loaded into memory - it's accessed on-demand.

 This validates UTF-8 on pattern string reads. Use for untrusted databases.

 # Parameters
 * `filename` - Path to database file (null-terminated C string, must not be NULL)

 # Returns
 * Non-null pointer on success
 * NULL on failure

 # Safety
 * `filename` must be a valid null-terminated C string

 # Example
 ```c
 matchy_t *db = matchy_open("threats.db");
 if (db == NULL) {
     fprintf(stderr, "Failed to open database\n");
     return 1;
 }
 ```
 */
struct matchy_t *matchy_open(const char *filename);

/*
 Open database from memory buffer (zero-copy)

 Creates a database handle from a memory buffer. No data is copied.

 # Parameters
 * `buffer` - Pointer to database data (must not be NULL)
 * `size` - Size of buffer in bytes (must be > 0)

 # Returns
 * Non-null pointer on success
 * NULL on failure

 # Safety
 * `buffer` must be valid for the lifetime of the database handle
 * Caller must not modify or free buffer while handle exists
 */
struct matchy_t *matchy_open_buffer(const uint8_t *buffer, uintptr_t size);

/*
 Get database statistics

 Returns statistics about query performance, cache effectiveness,
 and query distribution.

 # Parameters
 * `db` - Database handle (must not be NULL)
 * `stats` - Pointer to stats structure to fill (must not be NULL)

 # Safety
 * `db` must be a valid pointer from matchy_open
 * `stats` must be a valid pointer to matchy_stats_t

 # Example
 ```c
 matchy_stats_t stats;
 matchy_get_stats(db, &stats);
 printf("Total queries: %llu\n", stats.total_queries);

 // Calculate hit rate
 double cache_hit_rate = 0.0;
 if (stats.cache_hits + stats.cache_misses > 0) {
     cache_hit_rate = (double)stats.cache_hits /
                      (stats.cache_hits + stats.cache_misses);
 }
 printf("Cache hit rate: %.1f%%\n", cache_hit_rate * 100.0);
 ```
 */
void matchy_get_stats(const struct matchy_t *db, struct matchy_stats_t *stats);

/*
 Clear the query cache

 Removes all cached query results. Useful for benchmarking or
 forcing fresh lookups.

 # Parameters
 * `db` - Database handle (must not be NULL)

 # Safety
 * `db` must be a valid pointer from matchy_open

 # Example
 ```c
 // Do some queries (fills cache)
 matchy_query(db, "example.com");

 // Clear cache to force fresh lookups
 matchy_clear_cache(db);
 ```
 */
void matchy_clear_cache(const struct matchy_t *db);

/*
 Close database

 Closes the database and frees all associated resources.

 # Parameters
 * `db` - Database handle (may be NULL)

 # Safety
 * `db` must be NULL or a valid pointer from matchy_open
 * Must not be used after calling this function
 * Calling with NULL is safe (no-op)

 # Example
 ```c
 matchy_close(db);
 db = NULL;  // Good practice
 ```
 */
void matchy_close(struct matchy_t *db);

/*
 Unified query interface - automatically detects IP vs pattern

 Queries the database with an IP address or pattern. The function automatically
 detects the query type and uses the appropriate lookup method.

 Returns structured data as DataValue (cached internally).
 Use matchy_result_get_entry() to access structured data,
 or matchy_result_to_json() to convert to JSON.

 # Parameters
 * `db` - Database handle (must not be NULL)
 * `query` - IP address or pattern to search (null-terminated C string, must not be NULL)

 # Returns
 * matchy_result_t with found=true if match found
 * matchy_result_t with found=false if no match
 * Caller must free result with matchy_free_result

 # Safety
 * `db` must be a valid pointer from matchy_open
 * `query` must be a valid null-terminated C string

 # Example
 ```c
 matchy_result_t result = matchy_query(db, "1.2.3.4");
 if (result.found) {
     // Option 1: Get as JSON
     char *json = matchy_result_to_json(&result);
     printf("Found: %s\n", json);
     matchy_free_string(json);

     // Option 2: Access structured data
     matchy_entry_s entry;
     matchy_result_get_entry(&result, &entry);
     // ... use matchy_aget_value()
 }
 matchy_free_result(&result);
 ```
 */
struct matchy_result_t matchy_query(const struct matchy_t *db, const char *query);

/*
 Unified query interface - writes result into provided struct pointer

 Same as matchy_query but writes to a provided pointer instead of returning by value.
 This is more FFI-friendly for some languages/platforms (like Java JNA on ARM64).

 # Parameters
 * `db` - Database handle (must not be NULL)
 * `query` - IP address or pattern to search (null-terminated C string, must not be NULL)
 * `result` - Pointer to result struct to fill (must not be NULL)

 # Safety
 * `db` must be a valid pointer from matchy_open
 * `query` must be a valid null-terminated C string
 * `result` must be a valid pointer to a matchy_result_t

 # Example
 ```c
 matchy_result_t result;
 matchy_query_into(db, "1.2.3.4", &result);
 if (result.found) {
     // Use result...
 }
 matchy_free_result(&result);
 ```
 */
void matchy_query_into(const struct matchy_t *db, const char *query, struct matchy_result_t *result);

/*
 Free query result

 Frees the memory allocated for a query result.

 # Parameters
 * `result` - Pointer to result from matchy_query (must not be NULL)

 # Safety
 * `result` must be a valid pointer to a result from matchy_query
 * Must not be called twice on the same result
 */
void matchy_free_result(struct matchy_result_t *result);

/*
 Free a string returned by matchy

 # Parameters
 * `string` - String pointer returned by matchy (may be NULL)

 # Safety
 * `string` must be NULL or a pointer returned by matchy
 * Must not be called twice on the same pointer
 */
void matchy_free_string(char *string);

/*
 Get library version string

 # Returns
 * Version string (e.g., "0.4.0")
 * Pointer is valid for program lifetime, do not free
 */
const char *matchy_version(void);

/*
 Get database format description

 # Parameters
 * `db` - Database handle (must not be NULL)

 # Returns
 * Format string ("IP database", "Pattern database", or "Combined IP+Pattern database")
 * Pointer is valid for database lifetime, do not free
 * NULL if db is NULL

 # Safety
 * `db` must be a valid pointer from matchy_open
 */
const char *matchy_format(const struct matchy_t *db);

/*
 Check if database supports IP address lookups

 # Parameters
 * `db` - Database handle (must not be NULL)

 # Returns
 * true if database contains IP data
 * false if not or if db is NULL

 # Safety
 * `db` must be a valid pointer from matchy_open
 */
bool matchy_has_ip_data(const struct matchy_t *db);

/*
 Check if database supports string lookups (literals or globs)

 # Parameters
 * `db` - Database handle (must not be NULL)

 # Returns
 * true if database contains literal or glob data
 * false if not or if db is NULL

 # Safety
 * `db` must be a valid pointer from matchy_open
 */
bool matchy_has_string_data(const struct matchy_t *db);

/*
 Check if database supports literal (exact string) lookups

 # Parameters
 * `db` - Database handle (must not be NULL)

 # Returns
 * true if database contains literal hash data
 * false if not or if db is NULL

 # Safety
 * `db` must be a valid pointer from matchy_open
 */
bool matchy_has_literal_data(const struct matchy_t *db);

/*
 Check if database supports glob pattern lookups

 # Parameters
 * `db` - Database handle (must not be NULL)

 # Returns
 * true if database contains glob pattern data
 * false if not or if db is NULL

 # Safety
 * `db` must be a valid pointer from matchy_open
 */
bool matchy_has_glob_data(const struct matchy_t *db);

/*
 Check if database supports pattern matching (deprecated)

 # Parameters
 * `db` - Database handle (must not be NULL)

 # Returns
 * true if database contains pattern data
 * false if not or if db is NULL

 # Safety
 * `db` must be a valid pointer from matchy_open

 # Deprecated
 Use matchy_has_literal_data or matchy_has_glob_data instead
 */
bool matchy_has_pattern_data(const struct matchy_t *db);

/*
 Get database metadata as JSON string

 Returns MMDB metadata if available (for IP or combined databases).

 # Parameters
 * `db` - Database handle (must not be NULL)

 # Returns
 * JSON string containing metadata (caller must free with matchy_free_string)
 * NULL if no metadata available or db is NULL

 # Safety
 * `db` must be a valid pointer from matchy_open
 */
char *matchy_metadata(const struct matchy_t *db);

/*
 Get pattern string by ID

 Returns the pattern string for a given pattern ID.
 Only works for pattern or combined databases.

 # Parameters
 * `db` - Database handle (must not be NULL)
 * `pattern_id` - Pattern ID

 # Returns
 * Pattern string (caller must free with matchy_free_string)
 * NULL if pattern ID not found or db has no patterns

 # Safety
 * `db` must be a valid pointer from matchy_open
 */
char *matchy_get_pattern_string(const struct matchy_t *db, uint32_t pattern_id);

/*
 Get total number of patterns in database

 Returns the number of patterns in the database.
 Only works for pattern or combined databases.

 # Parameters
 * `db` - Database handle (must not be NULL)

 # Returns
 * Number of patterns (0 if no patterns or db is NULL)

 # Safety
 * `db` must be a valid pointer from matchy_open
 */
uintptr_t matchy_pattern_count(const struct matchy_t *db);

/*
 Get entry handle from query result

 This extracts the entry handle which can be used for data navigation.

 # Parameters
 * `result` - Query result (must not be NULL, must have found=true)
 * `entry` - Output entry handle (must not be NULL)

 # Returns
 * MATCHY_SUCCESS on success
 * MATCHY_ERROR_NO_DATA if result not found
 * MATCHY_ERROR_INVALID_PARAM if parameters invalid

 # Safety
 * `result` must be valid result from matchy_query
 * `entry` must be valid pointer to output struct
 * Result must not have been freed

 # Example
 ```c
 matchy_result_t result = matchy_query(db, "8.8.8.8");
 if (result.found) {
     matchy_entry_s entry;
     matchy_result_get_entry(&result, &entry);
 }
 ```
 */
int32_t matchy_result_get_entry(const struct matchy_result_t *result, struct matchy_entry_s *entry);

/*
 Get value using array of strings for path

 Like matchy_get_value but takes an array of strings instead of varargs.

 # Parameters
 * `entry` - Entry handle
 * `entry_data` - Output data
 * `path` - NULL-terminated array of string pointers

 # Returns
 * Same as matchy_get_value

 # Safety
 * Same as matchy_get_value
 * `path` must be NULL-terminated array

 # Example
 ```c
 const char *path[] = {"country", "iso_code", NULL};
 matchy_aget_value(&entry, &data, path);
 ```
 */
int32_t matchy_aget_value(const struct matchy_entry_s *entry, struct matchy_entry_data_t *entry_data, const char *const *path);

/*
 Get full entry data as linked list (tree traversal)

 This function traverses the entire data structure and returns it as
 a flattened linked list. Maps and arrays are expanded recursively.

 # Parameters
 * `entry` - Entry handle
 * `entry_data_list` - Output list pointer

 # Returns
 * MATCHY_SUCCESS on success
 * Error code on failure

 # Safety
 * `entry` must be valid
 * `entry_data_list` must be valid pointer
 * Caller must free result with matchy_free_entry_data_list

 # Example
 ```c
 matchy_entry_data_list_t *list = NULL;
 if (matchy_get_entry_data_list(&entry, &list) == MATCHY_SUCCESS) {
     for (matchy_entry_data_list_t *p = list; p != NULL; p = p->next) {
         // Process p->entry_data
     }
     matchy_free_entry_data_list(list);
 }
 ```
 */
int32_t matchy_get_entry_data_list(const struct matchy_entry_s *entry, struct matchy_entry_data_list_t **entry_data_list);

/*
 Free entry data list

 Frees the linked list returned by matchy_get_entry_data_list.

 # Parameters
 * `list` - List to free (may be NULL)

 # Safety
 * `list` must be from matchy_get_entry_data_list or NULL
 * Must not be freed twice
 */
void matchy_free_entry_data_list(struct matchy_entry_data_list_t *list);

/*
 Convert query result data to JSON string

 This is a convenience function to convert the structured DataValue
 to a JSON string for simple use cases.

 # Parameters
 * `result` - Query result (must not be NULL, must have found=true)

 # Returns
 * JSON string (caller must free with matchy_free_string)
 * NULL if result is NULL, not found, or conversion fails

 # Safety
 * `result` must be a valid pointer to a result from matchy_query
 * Result must not have been freed

 # Example
 ```c
 matchy_result_t result = matchy_query(db, "8.8.8.8");
 if (result.found) {
     char *json = matchy_result_to_json(&result);
     if (json) {
         printf("Data: %s\n", json);
         matchy_free_string(json);
     }
 }
 matchy_free_result(&result);
 ```
 */
char *matchy_result_to_json(const struct matchy_result_t *result);

/*
 Validate a database file

 Validates a .mxy database file to ensure it's safe to use.
 Returns MATCHY_SUCCESS if the database is valid, or an error code if invalid.

 # Parameters
 * `filename` - Path to database file (null-terminated C string, must not be NULL)
 * `level` - Validation level (MATCHY_VALIDATION_STANDARD or _STRICT)
 * `error_message` - Pointer to receive error message (may be NULL if not needed)
   If non-NULL and validation fails, receives a string that must be freed with matchy_free_string

 # Returns
 * MATCHY_SUCCESS (0) if database is valid
 * Error code < 0 if validation failed or parameters invalid

 # Safety
 * `filename` must be a valid null-terminated C string
 * If `error_message` is non-NULL, caller must free the returned string

 # Example
 ```c
 char *error = NULL;
 int result = matchy_validate("/path/to/database.mxy", MATCHY_VALIDATION_STRICT, &error);
 if (result != MATCHY_SUCCESS) {
     fprintf(stderr, "Validation failed: %s\n", error ? error : "unknown error");
     if (error) matchy_free_string(error);
     return 1;
 }
 printf("Database is valid and safe to use!\n");
 ```
 */
int32_t matchy_validate(const char *filename, int32_t level, char **error_message);

/*
 Create an extractor with specified extraction types

 # Parameters
 * `flags` - Bitmask of MATCHY_EXTRACT_* flags specifying what to extract

 # Returns
 * Non-null extractor handle on success
 * NULL on failure

 # Example
 ```c
 // Extract everything
 matchy_extractor_t *ext = matchy_extractor_create(MATCHY_EXTRACT_ALL);

 // Extract only domains and IPs
 matchy_extractor_t *ext = matchy_extractor_create(
     MATCHY_EXTRACT_DOMAINS | MATCHY_EXTRACT_IPV4 | MATCHY_EXTRACT_IPV6
 );
 ```
 */
struct matchy_extractor_t *matchy_extractor_create(uint32_t flags);

/*
 Extract patterns from a chunk of data

 Extracts all enabled pattern types (domains, IPs, emails, hashes, crypto)
 from the input data in a single pass.

 # Parameters
 * `extractor` - Extractor handle (must not be NULL)
 * `data` - Input data buffer (must not be NULL)
 * `len` - Length of input data in bytes
 * `matches` - Output matches structure (must not be NULL)

 # Returns
 * MATCHY_SUCCESS on success
 * MATCHY_ERROR_INVALID_PARAM if any parameter is NULL

 # Memory Management
 Caller must free the matches with matchy_matches_free()

 # Example
 ```c
 matchy_extractor_t *extractor = matchy_extractor_create(MATCHY_EXTRACT_ALL);
 const char *text = "Check evil.com and 192.168.1.1";
 matchy_matches_t matches;

 if (matchy_extractor_extract_chunk(extractor, (const uint8_t *)text, strlen(text), &matches) == MATCHY_SUCCESS) {
     for (size_t i = 0; i < matches.count; i++) {
         printf("%s: %s\n",
                matchy_item_type_name(matches.items[i].item_type),
                matches.items[i].value);
     }
     matchy_matches_free(&matches);
 }
 matchy_extractor_free(extractor);
 ```

 # Safety
 * `extractor` must be a valid pointer returned by `matchy_extractor_create`
 * `data` must point to a valid buffer of at least `len` bytes
 * `matches` must be a valid pointer to an uninitialized `matchy_matches_t`
 */
int32_t matchy_extractor_extract_chunk(const struct matchy_extractor_t *extractor, const uint8_t *data, uintptr_t len, struct matchy_matches_t *matches);

/*
 Free the matches returned by matchy_extractor_extract_chunk

 # Parameters
 * `matches` - Matches structure to free (must not be NULL)

 # Safety
 * Must not use the matches after calling this function
 */
void matchy_matches_free(struct matchy_matches_t *matches);

/*
 Free the extractor

 # Parameters
 * `extractor` - Extractor handle (may be NULL)

 # Safety
 * Must not be used after calling this function
 */
void matchy_extractor_free(struct matchy_extractor_t *extractor);

/*
 Get the string name for an item type constant

 # Parameters
 * `item_type` - One of the MATCHY_ITEM_TYPE_* constants

 # Returns
 * Static string like "Domain", "Email", "IPv4", etc.
 * "Unknown" for invalid type values

 # Note
 The returned string is static and must not be freed.
 */
const char *matchy_item_type_name(uint8_t item_type);

#ifdef __cplusplus
}  // extern "C"
#endif  // __cplusplus

#ifdef __cplusplus
}  // namespace matchy
#endif  // __cplusplus

#endif  /* MATCHY_H */
